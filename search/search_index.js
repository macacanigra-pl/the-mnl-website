var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Learn to program is a breeze!","text":"<p>Understandable</p> <p>The keyword is a whole word in English, not an abbreviation.</p> <ul> <li> <p> Easy to Learn!</p> <p> Just drag 'n drop, then attach or detach the block.</p> </li> <li> <p> Reactive Environment</p> <p> Reactive means action and reaction. When user makes any changes , MNL will response it with the result of evaluation or error if any.</p> </li> <li> <p> Shape and Color</p> <p> Assisting users by utilizing visual language capabilities: shapes and colors. Shapes will represent grammar, while colors will indicate value types.</p> </li> <li> <p> Type Inference</p> <p> Users do not need to declare the type explicitly! Let MNL do it for them (implicit typing).</p> </li> <li> <p> Program Visualization</p> <p> Show the beta reduction and the function value visually.</p> </li> <li> <p> It's a Functional PL</p> <p> MNL is a pure block-based functional programming language.</p> </li> <li> <p> YAKI</p> <p> MNL proudly presents a compiler, the Yet Another K/C Compiler Interface (YAKI). This powerful tool seamlessly transforms intuitive block-based programming languages into text-based languages like SML and Scala.</p> </li> <li> <p> Typing Rule</p> <p> Another YAKI capability is writing the typing derivation of MNL.</p> </li> <li> <p> Typing Suggestion</p> <p> MNL will elegantly present a suggested term type in a color box, thoughtfully aligned with its type constraints.</p> </li> </ul>"},{"location":"about.html","title":"About","text":"<p>Macaca Nigra Programming Language (MNL) is a block-based functional programming language designed to help users learn programming. It allows users to visualize all processes, such as beta reduction and function value. The language also uses visual capabilities such as shape and color to convey meaning to the user.</p> <p>However, it still needs improvement in certain areas to function effectively. These include enhancing the advanced circularity check (occurrence check) in type inference, optimizing memory usage for tail functions, and refining the continuation-passing style.</p>"},{"location":"user-guide/compiler.html","title":"The Compiler","text":"<p>MNL has a compiler named YAKI (Yet Another [K/C]Compiler Interface). It transforms block-based programming languages into text-based languages such as SML and Scala. Beyond compiling, YAKI could write a typing derivation of MNL.</p> <p>Users can access YAKI by right-clicking on the workspace and choosing <code>Compiler</code> to open the transpiler window. The combo box at the bottom allows users to select the target language.</p>"},{"location":"user-guide/compiler.html#example-the-identity-function","title":"Example: The Identity Function","text":"The Identity Function <p> The identity function is a function that returns the input value.</p> <p></p> <p>Fig. 1: The identity function</p> Typing DerivationSMLScala <p></p> identity_function.sml<pre><code>fun f_identity (a) = a\n</code></pre> identity_function.scala<pre><code>def f_identity [B] (a : B) : B = a \n</code></pre>"},{"location":"user-guide/function.html","title":"The Function","text":"<p>As in functional programming, MNL treats a function as a first-class citizen, meaning it can be bound to names, passed as an argument, and returned from another function. MNL has two types of function blocks: The function block and the lambda block.  The lambda block is an expression block that takes two inputs: a parameter and an expression block. On the other hand, the function block is a declarative block that consists of three inputs: an identifier (a name), a parameter, and an expression block.</p>"},{"location":"user-guide/function.html#the-lambda-block","title":"The Lambda Block","text":"<p>A lambda function, also known as an anonymous function, is a function that does not have a name. Figure 1 shows an incomplete lambda block, while Figures 2 to 4 provide examples of how to construct a lambda block.</p> <p></p> <p>Fig. 1: The lambda block</p> <p></p> <p>Fig. 2: The lambda block with the empty parameter and return a string</p> <p></p> <p>Fig. 3: The lambda block with a string input and produce a string output</p> <p>Naming a lambda block can be achieved by connecting the variable block with the lambda block.</p> <p></p> <p>Fig. 4: Lambda binding with a name.</p> SMLScala <pre><code>val mnl_say = fn (hello) =&gt; (\"MNL: \" ^ hello)\nval say_it = mnl_say(\"Hello there\")\n</code></pre> <pre><code>val mnl_say = (hello : String) =&gt; (\"MNL: \" + hello)\nval say_it = mnl_say(\"Hello there\")\n</code></pre>"},{"location":"user-guide/function.html#the-function-block","title":"The Function block","text":"<p>MNL simplifies the connection between the lambda block and the variable block within a single declaration block known as a function block.</p> <p></p> <p>Fig. 5: The function block</p> SMLScala <pre><code>fun greetings () = \"Hello there\"\nval say_it = greetings()\n</code></pre> <pre><code>def greetings () : String = \"Hello there\"\nval say_it = greetings()\n</code></pre>"},{"location":"user-guide/function.html#example","title":"Example","text":""},{"location":"user-guide/function.html#tail-function","title":"Tail Function","text":"<p>Fig. 6: The tail function</p> SMLScala <pre><code>fun tail_function (n) = if (n &lt;= 1)\n    then\n        1\n    else\n        (n * tail_function((n - 1)))\n</code></pre> <pre><code>def tail_function (n: Float) : Float = if (n &lt;= 1)\n    then\n        1\n    else\n        (n * tail_function((n - 1)))\n</code></pre>"},{"location":"user-guide/function.html#two-or-more-parameters","title":"Two or more parameters","text":"<p>The core language of MNL is the lambda calculus, which takes one parameter. However, MNL can use a tuple or a record to accommodate two or more inputs as parameters. The examples below illustrate how to group two inputs into a single parameter.</p>"},{"location":"user-guide/function.html#tuple","title":"Tuple","text":"<p>Fig. 7: A tuple as the function parameter</p> SMLScala <pre><code>(* SML does not support type inference for a tuple as a parameter. \nOther ML languages may support the syntax below. *)\n</code></pre> <pre><code>/* the first item name/ index is 0 in scala */\ndef greetings (tpl: (String, String)) : String = ((tpl(0)) + (tpl(1)))\nval greetings_1 = greetings((\"Hello \", \"World!\"))\nval greetings_2 = greetings((\"World!\", \"Hello \"))\n</code></pre>"},{"location":"user-guide/function.html#record","title":"Record","text":"<p>Fig. 8: A record as the function parameter</p> SMLScala <pre><code> (* SML does not support type inference for a record as a parameter. \nOther ML languages may support the syntax below. *)\n</code></pre> <pre><code>/* Scala doesn't have primitive type of 'Record' */\n</code></pre>"},{"location":"user-guide/getting-started.html","title":"Getting Started","text":""},{"location":"user-guide/getting-started.html#just-drag-drop-and-attach-the-block","title":"Just Drag, Drop, and Attach the block","text":"<p>To start constructing a program in MNL, drag a block from the toolbox to the playground area and attach it to another block. A main block (1) acts as the parent block. The main block holds the declaration block only.</p> <ol> <li> The black block with MNL on the top.</li> </ol> <p> </p> <p>Fig. 1: Drag, drop, and attach the block</p>"},{"location":"user-guide/getting-started.html#declaration","title":"Declaration","text":"<p>A declaration means binding a name to a value. In MNL, there are two declaration blocks: variable and function. The function block is a simple model of binding a variable block with a lambda block.</p>"},{"location":"user-guide/getting-started.html#variable","title":"Variable","text":"<p>Creating a complete variable block requires an identity block and an expression block. The example below shows how to give a <code>variable_in_MNL</code> name to the string <code>MNL is easy to learn.</code> When users need the <code>MNL is easy to learn</code> value, they access the bound variable by name <code>variable_in_MNL</code>.</p> <p></p> <p>Fig. 2: Variable binding</p> SMLScala <pre><code>val variable_in_MNL = \"MNL is easy to learn\"\n</code></pre> <pre><code>val variable_in_MNL = \"MNL is easy to learn\"\n</code></pre>"},{"location":"user-guide/getting-started.html#expression","title":"Expression","text":"<p>Expression is a value. Every expression block has its value, including operators, constants, and constructors.</p>"},{"location":"user-guide/getting-started.html#operator","title":"Operator","text":"<p>There are two types of primitive operators based on input: unary (1) and binary (2) operators.</p> <ol> <li> Take one input.</li> <li> Take two inputs.</li> </ol>"},{"location":"user-guide/getting-started.html#unary","title":"Unary","text":"<p>Fig. 3: Boolean Operator Not</p> SMLScala <pre><code>(not false)\n</code></pre> <pre><code>(!false)\n</code></pre> <p></p> <p>Fig. 4: Boolean Operator Not - binding</p> SMLScala <pre><code>val unary_operator = (not false)\n</code></pre> <pre><code>val unary_operator = (!false)\n</code></pre>"},{"location":"user-guide/getting-started.html#binary","title":"Binary","text":"<p>Fig. 5: Arithmetic Operator</p> SMLScala <pre><code>(111 + 222)\n</code></pre> <pre><code>(111 + 222)\n</code></pre> <p></p> <p>Fig. 6: Arithmetic Operator - binding</p> SMLScala <pre><code>fun increment (n) = (1 + n)\n  val three = increment(2)\n</code></pre> <pre><code>def increment (n: Float) : Float = (1 + n)\nval three = increment(2)\n</code></pre>"},{"location":"user-guide/getting-started.html#selection","title":"Selection","text":"<p>Fig. 7: Selection</p> SMLScala <pre><code>(* SML does not support type inference for a tuple as a parameter. \nOther ML languages may support the syntax below. *)\nfun the_greater (pair) = if ((#1 pair) &lt; (#2 pair))\n  then\n    (#2 pair)\n  else\n    (#1 pair)\n\nval two_or_three = the_greater((2, 3))\n</code></pre> <pre><code>def the_greater (pair: (Float, Float)) : Float = if ((pair(0)) &lt; (pair(1)))\n  then\n    (pair(1))\n  else\n    (pair(0))\n\nval two_or_three = the_greater((2, 3))\n</code></pre>"},{"location":"user-guide/getting-started.html#sequence","title":"Sequence","text":"<p>A sequence is a collection of expressions that are evaluated sequentially. The last expression is the type and value of a sequence block.</p> <p> </p> <p>Fig. 8: Sequence</p> SMLScala <pre><code>val sequence = (\n  \"Hi, there!\";\n  \"I am MNL\"\n)\n</code></pre> <pre><code>val sequence = (() =&gt;{\n  \"Hi, there!\"\n  \"I am MNL\"\n})()\n</code></pre>"},{"location":"user-guide/getting-started.html#pattern-matching","title":"Pattern Matching","text":"<p>Fig. 9: Pattern Matching</p> SMLScala <pre><code>fun translator_good_morning (lang_code) = case lang_code\n  of \"en\" =&gt; \"Good Morning\"\n  | \"de\" =&gt; \"Guten Morgen\"\n  | \"jp\" =&gt; \"\u304a\u306f\u3088\u3046\"\n  | \"id\" =&gt; \"Selamat Pagi\"\n  |  _   =&gt; \"Unknown\"\n\nval greetings = translator_good_morning(\"de\")\n</code></pre> <pre><code>def translator_good_morning (lang_code: String) : String = lang_code match\n  case \"en\" =&gt; \"Good Morning\"\n  case \"de\" =&gt; \"Guten Morgen\"\n  case \"jp\" =&gt; \"\u304a\u306f\u3088\u3046\"\n  case \"id\" =&gt; \"Selamat Pagi\"\n  case _   =&gt; \"Unknown\"\n\nval greetings = translator_good_morning(\"de\")\n</code></pre>"},{"location":"user-guide/getting-started.html#let-in","title":"Let-in","text":"<p>Let-in is a local binding of the declaration(s) in the expression.</p> <p></p> <p>Fig. 10: Let-in</p> SMLScala <pre><code>val let_in = let\n  val hello = \"Hello \"\n  fun speech (name) = (hello ^ name)\n  in\n    speech(\"MNL\")\n  end\n</code></pre> <pre><code>val let_in = (() =&gt; {\n  val hello = \"Hello \"\n  def speech (name: String) : String = (hello + name)\n\n  speech(\"MNL\")\n})()\n</code></pre>"},{"location":"user-guide/hof.html","title":"The Higher-Order Function (HOF)","text":"<p>A higher-order function (HOF) is a function that can take another function as an input (parameter) or return a function as its output, or both.</p>"},{"location":"user-guide/hof.html#function-as-a-parameter","title":"Function as a parameter","text":"<p>Fig. 1: A function as a parameter</p> SMLScala <pre><code>    fun fold_list (list_a) = fn (accumulator) =&gt; fn (operator) =&gt; let\n      fun supporter (list_b) = if null(list_b)\n        then\n        accumulator\n        else\n        operator(hd(list_b) ) (supporter(tl(list_b) ) )\n    in\n      supporter(list_a)\n    end\n    fun sum (a) = fn (b) =&gt; (a + b)\n    val application_of_fold = fold_list([17, 2, 2004]) (0) (sum)\n</code></pre> <pre><code>/* Scala doesn't support type variable on lambda */\n</code></pre>"},{"location":"user-guide/hof.html#return-a-function","title":"Return a function","text":"<p>Fig. 2: Return a function</p> SMLScala <pre><code>  fun f_continuation (param_1) = fn (param_2) =&gt; fn (param_3) =&gt; (param_1 ^ (param_2 ^ param_3) )\n  val first_app = f_continuation(\"Hello \")\n  val second_app = first_app(\"World\")\n  val the_result = second_app(\"!\")\n</code></pre> <pre><code>  def f_continuation (param_1: String) : (String) =&gt; (String) =&gt; String = (param_2 : String) =&gt; (param_3 : String) =&gt; (param_1 + (param_2 + param_3) )\n  val first_app = f_continuation(\"Hello \")\n  val second_app = first_app(\"World\")\n  val the_result = second_app(\"!\")\n</code></pre>"},{"location":"user-guide/list.html","title":"The List","text":"<p>A list is a container with a collection of items of the same type. It can either be empty or contain one or more items.</p>"},{"location":"user-guide/list.html#constructing-the-list","title":"Constructing the list","text":""},{"location":"user-guide/list.html#empty-list","title":"Empty list","text":"<p>Constructing an empty list block, simply remove all members from the input block toolbox [\u2699].</p> <p></p> <p>Fig. 1: The empty list block</p> SMLScala <pre><code>[]\n</code></pre> <pre><code>List()\n</code></pre> <p></p> <p>Fig. 2: Connecting the empty list block to the variable block</p> SMLScala <pre><code>val list_constructor = []\n</code></pre> <pre><code>val list_constructor = List()\n</code></pre>"},{"location":"user-guide/list.html#non-empty-list","title":"Non-empty list","text":"<p>The inhabitants of the list can be added or removed using the input block toolbox.</p> <p></p> <p>Fig. 3: Constructing the non-empty list block</p> SMLScala <pre><code>[\"my name \", \"is \", \"MNL\"]\n</code></pre> <pre><code>List(\"my name \", \"is \", \"MNL\")\n</code></pre> <p></p> <p>Fig. 4: Connecting the non-empty list block to the variable block</p> SMLScala <pre><code>val list_constructor = [\"my name \", \"is \", \"MNL\"]\n</code></pre> <pre><code>val list_constructor = List(\"my name \", \"is \", \"MNL\")\n</code></pre>"},{"location":"user-guide/list.html#operator","title":"Operator","text":""},{"location":"user-guide/list.html#is-empty","title":"is empty","text":"<p>To check whether the list is empty, return true when it is empty; otherwise, return false.</p> <p></p> <p>Fig. 5: The is-empty block operator with the empty list block</p> SMLScala <pre><code>val list_constructor = null([])\n</code></pre> <pre><code>val list_constructor = List().isEmpty\n</code></pre> <p></p> <p>Fig. 6: The is-empty block operator with the non-empty list block</p> SMLScala <pre><code>val list_constructor = null([])\n</code></pre> <pre><code>val list_constructor = List().isEmpty\n</code></pre>"},{"location":"user-guide/list.html#head","title":"head","text":"<p>Retrieve the first inhabitant from the list. </p> <p></p> <p>Fig. 7: The head list operator block</p> SMLScala <pre><code>hd([\"My name \", \"is \", \"MNL\"])\n</code></pre> <pre><code>List(\"My name \", \"is \", \"MNL\").head\n</code></pre>"},{"location":"user-guide/list.html#tail","title":"tail","text":"<p>Obtain the inhabitants of the list, starting from the second inhabitant to the last one.</p> <p></p> <p>Fig. 8: The tail list operator block</p> SMLScala <pre><code>tl([\"My name \", \"is \", \"MNL\"])\n</code></pre> <pre><code>List(\"My name \", \"is \", \"MNL\").tail\n</code></pre>"},{"location":"user-guide/list.html#append","title":"append","text":"<p>Insert a new inhabitant into the list and put it into the first position.</p> <p></p> <p>Fig. 9: The append list operator block</p> SMLScala <pre><code>(\"Hello, \" :: [\"My name \", \"is \", \"MNL\"])\n</code></pre> <pre><code>(\"Hello, \" :: List(\"My name \", \"is \", \"MNL\"))\n</code></pre> <p></p> <p>Fig. 10: The append a new inhabitant and bind to a variable block.</p> SMLScala <pre><code>val my_name_is_mnl = [\"My name\", \"is\", \"MNL\"]\nval hello = (\"Hello, \" :: my_name_is_mnl)\n</code></pre> <pre><code>val my_name_is_mnl = List(\"My name\", \"is\", \"MNL\")\nval hello = (\"Hello, \" :: my_name_is_mnl)\n</code></pre>"},{"location":"user-guide/list.html#example","title":"Example","text":""},{"location":"user-guide/list.html#sum","title":"Sum","text":"<p>Fig. 11: The head list operator block</p> SMLScala <pre><code>fun sum_list (list_a) = if null(list_a)\n  then\n    0\n  else\n    (hd(list_a)  + sum_list(tl(list_a)))\n\nval sum_list_application = sum_list([17, 2, 200, 4])\n</code></pre> <pre><code>def sum_list (list_a: List[Float]) : Float = if (list_a.isEmpty)\n  then\n    0\n  else\n    ((list_a.head)  + sum_list((list_a.tail)))\n\nval sum_list_application = sum_list(List(17, 2, 200, 4))\n</code></pre>"},{"location":"user-guide/overview.html","title":"Overview","text":""},{"location":"user-guide/overview.html#workspace","title":"Workspace","text":"<p>The MnL workspace is divided into Menu, Toolbox and Top-level block, and Playground.</p> <p> </p> <p>Fig. 1: Workspace</p>"},{"location":"user-guide/overview.html#menu","title":"Menu","text":"<p> <code>File</code>: start a new workspace, save and download blocks on the Playground, or upload and load blocks into the Playground.</p> <p> <code>Theme</code>: change the workspace theme to dark or light mode.</p> <p> <code>Basic Example</code>: load basic examples such as the identity and recursive functions, etc.</p> <p> <code>Advanced Example</code>: load an advanced example such as the filter, fold, or fmap function.</p> <p> <code>Program Visualization and Transpiler</code>: show/ hide window of the function value, beta reduction, or transpiler.</p> <p> <code>Usage</code>: go to the user guide website.</p>"},{"location":"user-guide/overview.html#toolbox-and-top-level-block","title":"Toolbox and Top-level block","text":"<p> <code>Toolbox icon</code>: clickable icon to show or hide toolbox.</p> <p> <code>Search</code>: search block by name.</p> <p> <code>Top-level block</code>: used as the parent block for the program construction.. </p>"},{"location":"user-guide/overview.html#playground","title":"Playground","text":"<p> <code>Trash</code>: hold all deleted blocks.</p> <p> <code>Zoom in/out</code>: Zoom in/ out of the play area.</p> <p> <code>Rest</code>: reset the play area position.</p> <p> <code>Play Area</code>: holds all blocks.</p>"},{"location":"user-guide/overview.html#toolbox","title":"Toolbox","text":"<p>Toolbox groups the blocks based on the language grammar. To show the block in the category, click the category. There are seven categories on the top; the other seven below are part of the expression. The user can also search the block from the search box located at the bottom of the toolbox.</p> <p> </p> <p>Fig. 2: Toolbox</p>"},{"location":"user-guide/overview.html#block-anatomy","title":"Block Anatomy","text":"<p>Fig. 3: Horizontal input/output block</p> <p></p> <p>Fig. 4: Vertical input/output + horizontal input block</p> <p> <code>Gear Icon</code>: show the add/remove input block toolbox.</p> <p> <code>Exclamation Mark Icon</code>: Debugger, shows the error message.</p> <p> <code>Question Mark Icon</code>: The Info shows the block information: block category, type, and value.</p> <p> <code>Suggestion Box Color</code>: shows the colors of blocks that can be connected.</p> <p> <code>The Input Notch</code>: shows the shape of the required output notch to attach to the block.</p> <p> <code>The Output Notch</code>: used as a hook to another block.</p>"},{"location":"user-guide/overview.html#addremove-input","title":"Add/Remove Input","text":"<p>The number of input blocks on some blocks can be adjusted dynamically using the add/remove toolbox or add/remove icon.</p> <p> </p> <p>Fig. 5: Add/remove input toolbox</p> <p></p> <p>Fig. 6: Add/remove input using icon</p>"},{"location":"user-guide/overview.html#block-info","title":"Block Info","text":"<p>The Info shows block information such as block category based on the grammar, value type (term type), and value.</p> <p> </p> <p>Fig. 7: The Info</p>"},{"location":"user-guide/overview.html#the-shape-and-color","title":"The Shape and Color","text":"<p>The shape of the input/output notch of the block represents the non-terminal of the grammar. The block color represents the term type, such as blue for function, yellow for number, etc..</p>"},{"location":"user-guide/overview.html#debugger","title":"Debugger","text":"<p>The debugger shows the requirement to make a complete block (1) or the term-type error.</p> <ol> <li> A complete block is a block with all requirements fulfilled, ex.: Fig.7 The Info.</li> </ol> <p> </p> <p>Fig. 8: Debugger</p>"},{"location":"user-guide/program-visualization.html","title":"Program Visualisation","text":"<p>MNL features a program visualization tool called Tarsius. Tarsius was designed specifically for program visualization, which means that all evaluations are conducted within a visual workspace. This approach differs from traditional text-based programming languages, where it can be challenging to illustrate function values or the process of function application (beta reduction). Tarsius can visually display both the function value and all the steps in the beta reduction process during substitution and computation.</p>"},{"location":"user-guide/program-visualization.html#the-function-value","title":"The Function Value","text":"<p>When the expression block type is <code>function</code>, users can view the contents of the function value by right-clicking on the block and selecting <code>Function Value</code> from the block menu.</p> <p> </p> <p>Fig. 1: The function value's menu</p> <p> </p> <p>Fig. 2: The content of function's value</p>"},{"location":"user-guide/program-visualization.html#beta-reduction","title":"Beta Reduction","text":"<p>Users can display the beta reduction process by right-clicking on the application block and selecting <code>Beta Reduction</code>. In the beta reduction window, they will see the substitution steps arranged sequentially from top to bottom, along with their corresponding values.</p> <p> </p> <p>Fig. 3: The beta reduction's menu</p> <p> </p> <p>Fig. 4: Beta reduction</p>"},{"location":"user-guide/record.html","title":"Record","text":"<p>A record is a data structure that comprises a fixed number of fields. Each field has an identifier and an associated expression. In contrast with a tuple, where the names of the fields are implicitly assigned based on their order, a record allows users to define the names of its fields.</p>"},{"location":"user-guide/record.html#constructor","title":"Constructor","text":"<p>Fig. 1: Record constructor</p> SMLScala <pre><code>{bool = false, str = \"is\", num = 0}\n</code></pre> <pre><code>/* Scala doesn't have primitive type of 'Record' */\n</code></pre> <p></p> <p>Fig. 2: Binding a record constructor with a name</p> SMLScala <pre><code>val record_constructor = {bool = false, str = \"is\", num = 0}\n</code></pre> <pre><code>/* Scala doesn't have primitive type of 'Record' */\n</code></pre>"},{"location":"user-guide/record.html#projection","title":"Projection","text":"<p>Projection is an operator that retrieves a specific field using its name.</p> <p></p> <p>Fig. 3: Record projection</p> SMLScala <pre><code>(#str {bool = false, str = \"is\", num = 0})\n</code></pre> <pre><code>/* Scala doesn't have primitive type of 'Record' */\n</code></pre> <p></p> <p>Fig. 4: Application of record projection over a bound variable.</p> SMLScala <pre><code>val record_constructor = {bool = false, str = \"is\", num = 0}\nval projection = (#str record_constructor)\n</code></pre> <pre><code>/* Scala doesn't have primitive type of 'Record' */\n</code></pre>"},{"location":"user-guide/tuple.html","title":"Tuple","text":"<p>A tuple is a container with a collection of inhabitants with the same or different term types. Its size is fixed, and it cannot be empty.</p>"},{"location":"user-guide/tuple.html#constructor","title":"Constructor","text":"<p>Fig. 1: Tuple constructor</p> SMLScala <pre><code>(true, \"is\", 1)\n</code></pre> <pre><code>(true, \"is\", 1)\n</code></pre> <p></p> <p>Fig. 2: Binding a tuple</p> SMLScala <pre><code>val tuple_constructor = (true, \"is\", 1)\n</code></pre> <pre><code>val tuple_constructor = (true, \"is\", 1)\n</code></pre>"},{"location":"user-guide/tuple.html#projection","title":"Projection","text":"<p>Projection is an operator that retrieves one element from a tuple at a specific location.</p> <p></p> <p>Fig. 3: Tuple projection</p> SMLScala <pre><code>val tuple_constructor = (true, \"is\", 1)\nval projection = (#1 tuple_constructor)\n</code></pre> <pre><code>val tuple_constructor = (true, \"is\", 1)\nval projection = (tuple_constructor(1))\n</code></pre>"},{"location":"user-guide/type-inference.html","title":"Type Inference","text":"<p>The term type of the variable block (Fig. 1) and operator block (Fig. 2) depends on the attached block. If the block is incomplete, its default term type is <code>any</code>.</p> <p></p> <p>Fig. 1: The variable block term type is <code>any</code></p> <p></p> <p>Fig. 2: The operator block term type is any</p> <p>When the operator block is complete, it will implicitly infer the term type. For example, the variable block term type on Fig. 3 is inferred from the <code>ASCII to Character block</code> term type, and the operator block term type on Fig. 4 is inferred from the second inhabitant of <code>the tuple constructor block</code>.</p> <p></p> <p>Fig. 3: Infer the term type form operator</p> <p></p> <p>Fig. 4: The operator block term type is <code>number</code></p>"},{"location":"user-guide/type-suggestion.html","title":"Type Suggestion","text":"<p>One of MNL's capabilities is type suggestion. MNL will show the suggestion type by coloring the rounded box near the input notch.</p> <p>Initially, MNL will color the suggestion box with the color of the term type <code>any</code> (dark silver), but when the term type is successfully inferred, the color will change accordingly.</p> <p></p> <p>Fig. 1: Suggestion type on the incomplete block</p> <p>However, when the block has some attached input (The partially completed block (1) ), MNL will construct the type based on the type constraint rule and update the suggestion box color. The example below shows the color of the suggestion box on the input notch.</p> <ol> <li> The partially completed block has a block with some attached input blocks, but not all input notches have connected with the input block.</li> </ol> <p></p> <p></p> <p>Fig. 2: The partially completed block</p> <p>Users can check whether the input block complies with the typing rule when it is complete. For example, the completed block below, the input block attached to the otherwise input, does not comply with the typing rule. The typing rule required the block with the green color (2), but it found the block with the yellow color (3).</p> <ol> <li> The completed block is a block with all input notches connected to the input block.</li> <li> The green color is the color for the type string.</li> <li> The yellow color is the color for the type number.</li> </ol> <p></p> <p>Fig. 3: The completed block</p> <p>When the type constraint builder cannot find the type from the attached input block, but the block has a parent block, it will infer the type from the parent block.</p> <p></p> <p></p> <p>Fig. 4: Infer from the parent block</p> <p>The type constraint builder tries to infer the type from the attached input block first, then the parent block. </p> <p></p> <p>Fig. 5: Start from the attached block, then the parent block</p>"}]}